Data conversion of generated csv(char format) to MCode 
//1)Address conversion logic used in firmware
//2)Address conversion example 


#define BITBAND_SRAM_BASE 0x20000000
#define ALIAS_SRAM_BASE 0x22000000
#define BITBAND_SRAM(a,b) ((ALIAS_SRAM_BASE + (a-BITBAND_SRAM_BASE)*32 + (b*4)))
#define BIT_OFFSET 8
#define BITBAND_PERI_BASE 0x40000000
#define ALIAS_PERI_BASE 0x42000000
#define BITBAND_PERI(a,b) ((ALIAS_PERI_BASE + (a-BITBAND_PERI_BASE)*32 + (b*4)))


#define OUTPUT_BIT_BASE_ADD		0x2001C000
#define INPUT_BIT_BASE_ADD		0x2001C200
#define FLAG_BIT_BASE_ADD		0x2001C400
#define STATUS_BIT_BASE_ADD 	0x2001C420
#define INTEGER_BIT_BASE_ADD 	0x2001C620
#define FLOAT_BIT_BASE_ADD 		0x2001C820
#define TIMER_BIT_BASE_ADD 		0x2001CC20
#define COUNTER_BIT_BASE_ADD 	0x2001CE20
#define RETENTIVE_FLAG_BASE_ADD 0x2001D020
#define RETENTIVE_WORD_BASE_ADD 0x2001D040
#define D_AUTO_BIT_BASE_ADD     0x2001D240



#define INPUT_WORD_ADDRESS(a) 		(INPUT_BIT_BASE_ADD + (a * 2))
#define OUTPUT_WORD_ADDRESS(a) 		(OUTPUT_BIT_BASE_ADD + (a * 2))
#define FLAG_WORD_ADDRESS(a) 		(FLAG_BIT_BASE_ADD + (a/8))
#define STATUS_WORD_ADDRESS(a) 		(STATUS_BIT_BASE_ADD + (a * 2))
#define INTEGER_WORD_ADDRESS(a) 	(INTEGER_BIT_BASE_ADD + (a * 2))
#define FLOAT_WORD_ADDRESS(a) 		(FLOAT_BIT_BASE_ADD + (a * 4))
#define TIMER_WORD_ADDRESS(a) 		(TIMER_BIT_BASE_ADD + (a * 2))
#define COUNTER_WORD_ADDRESS(a) 	(COUNTER_BIT_BASE_ADD + (a * 2))
#define RETENTIVE_FLAG_ADDRESS(a) 	(RETENTIVE_FLAG_BASE_ADD + (a/8))
#define RETENTIVE_WORD_ADDRESS(a)	(RETENTIVE_WORD_BASE_ADD + (a * 2))
#define D_AUTO_WORD_ADDRESS(a)      (D_AUTO_BIT_BASE_ADD + (a/8))



//1) Address conversion logic used in firmware

uint32_t OP1_String_To_Address(ST_STR_LOGIC_FILE *lstStrLogicFile, uint16_t lbRowCount, uint16_t lbCount)
{
    static uint32_t ldOPBuff = 0;
    uint32_t ldWordAddress=0;
    uint32_t ldWord =0, ldBit=0;


	switch(lstStrLogicFile->OP1[lbRowCount][lbCount])
	{
	case 'I':
		ldWord = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+3]);
		ldBit = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+7]);
		ldWordAddress = INPUT_WORD_ADDRESS(ldWord);
		if((lstStrLogicFile->OP1[lbRowCount][lbCount+6])== '.')
		{
			if((ldBit>=0) && (ldBit<=7))
			{
				ldOPBuff = BITBAND_SRAM(ldWordAddress,ldBit);
			}
			else if((ldBit>= 8)&&(ldBit<=15))
			{
				ldWordAddress +=1;
				ldOPBuff = BITBAND_SRAM(ldWordAddress,(ldBit - BIT_OFFSET));
			}
		}
		else
		{
			ldOPBuff = ldWordAddress;
		}
		break;
case 'Q':
		ldWord = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+3]);
		ldBit = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+7]);
		ldWordAddress = OUTPUT_WORD_ADDRESS(ldWord);
		if((lstStrLogicFile->OP1[lbRowCount][lbCount+6])== '.')
		{
			if((ldBit>=0) && (ldBit<=7))
			{
				ldOPBuff = BITBAND_SRAM(ldWordAddress,ldBit);
			}
			else if((ldBit>= 8)&&(ldBit<=15))
			{
				ldWordAddress +=1;
				ldOPBuff = BITBAND_SRAM(ldWordAddress,(ldBit - BIT_OFFSET));
			}
		}
		else
		{
			ldOPBuff = ldWordAddress;
		}
		break;
	case 'F':
		ldWord = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+3]);
		ldWordAddress = FLAG_WORD_ADDRESS(ldWord);
		ldBit = ldWord%8;
		ldOPBuff = BITBAND_SRAM(ldWordAddress,ldBit);
        break;

    case 'D':
		ldWord = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+4]);
		ldWordAddress = D_AUTO_WORD_ADDRESS(ldWord);
		ldBit = ldWord%8;
		ldOPBuff = BITBAND_SRAM(ldWordAddress,ldBit);
		break;

	case 'W':
		ldWord = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+3]);
		ldBit = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+7]);
		ldWordAddress = INTEGER_WORD_ADDRESS(ldWord);
		if((lstStrLogicFile->OP1[lbRowCount][lbCount+6])== '.')
		{
			if((ldBit>=0) && (ldBit<=7))
			{
				ldOPBuff = BITBAND_SRAM(ldWordAddress,ldBit);
			}
			else if((ldBit>= 8)&&(ldBit<=15))
			{
				ldWordAddress +=1;
				ldOPBuff = BITBAND_SRAM(ldWordAddress,(ldBit - BIT_OFFSET));
			}
		}
		else
		{
			ldOPBuff = ldWordAddress;
		}
		break;
	case 'P':
		ldWord = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+3]);
		ldBit = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+7]);
		ldWordAddress = FLOAT_WORD_ADDRESS(ldWord);
		if((lstStrLogicFile->OP1[lbRowCount][lbCount+6])== '.')
		{
			if((ldBit>=0) && (ldBit<=7))
			{
				ldOPBuff = BITBAND_SRAM(ldWordAddress,ldBit);
			}
			else if((ldBit>= 8)&&(ldBit<=15))
			{
				ldWordAddress +=1;
				ldOPBuff = BITBAND_SRAM(ldWordAddress,(ldBit - BIT_OFFSET));
			}
		}
		else
		{
			ldOPBuff = ldWordAddress;
		}
		break;
	case 'T':
		ldWord = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+3]);
		ldBit = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+7]);
		ldWordAddress = TIMER_WORD_ADDRESS(ldWord);
		if((lstStrLogicFile->OP1[lbRowCount][lbCount+6])== '.')
		{
			if((ldBit>=0) && (ldBit<=7))
			{
				ldOPBuff = BITBAND_SRAM(ldWordAddress,ldBit);
			}
			else if((ldBit>= 8)&&(ldBit<=15))
			{
				ldWordAddress +=1;
				ldOPBuff = BITBAND_SRAM(ldWordAddress,(ldBit - BIT_OFFSET));
			}
		}
		else
		{
			ldOPBuff = ldWordAddress;
		}
		break;
	case 'C':
		ldWord = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+3]);
		ldBit = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+7]);
		ldWordAddress = COUNTER_WORD_ADDRESS(ldWord);
		if((lstStrLogicFile->OP1[lbRowCount][lbCount+6])== '.')
		{
			if((ldBit>=0) && (ldBit<=7))
			{
				ldOPBuff = BITBAND_SRAM(ldWordAddress,ldBit);
			}
			else if((ldBit>= 8)&&(ldBit<=15))
			{
				ldWordAddress +=1;
				ldOPBuff = BITBAND_SRAM(ldWordAddress,(ldBit - BIT_OFFSET));
			}
		}
		else
		{
			ldOPBuff = ldWordAddress;
		}
		break;

	case 'Y':
		ldWord = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+3]);
		ldBit = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+7]);
		ldWordAddress = RETENTIVE_WORD_ADDRESS(ldWord);
		ldOPBuff=ldWordAddress;
		break;

	case 'X':
		ldWord = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+3]);
		ldWordAddress = RETENTIVE_FLAG_ADDRESS(ldWord);
		ldBit = ldWord%8;
		ldOPBuff = BITBAND_SRAM(ldWordAddress,ldBit);
		break;
	case 'S':
		ldWord = atoi(&lstStrLogicFile->OP1[lbRowCount][lbCount+3]);
		ldOPBuff = STATUS_WORD_ADDRESS(ldWord);
		break;
	}
	return ldOPBuff;
}





//2) Example(psudo)code for Adress conversion 

uint32_t OP1_String_To_Address()
{
    //Address array[11]

	switch(check start char of add.)                  
	{      
	case 'I':                           //ip_add=I1:000.00                
		ldWord = atoi(ip_add+3);                                       //increment add by 3 & Read word add & convert ascii to int.
		ldBit = atoi(ip_add+7);                                        // increment add by 7 Read bit add & convert ascii to int.
		
		//  INPUT_BIT_BASE_ADD	   0x2001C200	
		// INPUT_WORD_ADDRESS(a) 		(INPUT_BIT_BASE_ADD + (a * 2))	//(0x2001C200+(0*2))=0x2001C200
		ldWordAddress = INPUT_WORD_ADDRESS(ldWord);                     //Convert add into memory address declaired in micros

		
		if((ip_add+6)== '.')                                            //check if 7th position of address is . 
		{
			if((ldBit>=0) && (ldBit<=7))
			{		
			// BITBAND_SRAM_BASE   0x20000000
			// ALIAS_SRAM_BASE 		0x22000000
			//((ALIAS_SRAM_BASE + (a-BITBAND_SRAM_BASE)*32 + (b*4)))
			//(0x22000000+( 0x2001C200-0x20000000)*32+(0*4))
				ldOPBuff = BITBAND_SRAM(ldWordAddress,ldBit);              //BITBAND_SRAM(a,b)=0x22384000
			}
			else if((ldBit>= 8)&&(ldBit<=15))                                 //check for 2nd Byte add of word add.
			{
				ldWordAddress +=1;
				ldOPBuff = BITBAND_SRAM(ldWordAddress,(ldBit - BIT_OFFSET));      //bit offset=8
			}
		}
				else
		{
			ldOPBuff = ldWordAddress;
		}
		break;
		
	case 'F':      //Flag_add1[11]=F1:001
		ldWord = atoi(Flag_add1+3]);        				        //1
		
		//(FLAG_BIT_BASE_ADD + (a/8))
		//( 0x2001C400 +(1/8))
		ldWordAddress = FLAG_WORD_ADDRESS(ldWord);                  //0x2001c400
		ldBit = ldWord%8;                                           //1
		
		//((ALIAS_SRAM_BASE + (a-BITBAND_SRAM_BASE)*32 + (b*4)))
		// (0x22000000+((0x2001c400-0x20000000)*32) +(1*4)))
		ldOPBuff = BITBAND_SRAM(ldWordAddress,ldBit);               //0x22388004
        break;
		
		
	case 'Q':     //Bit and Word Address
	   break;
	
	case 'W':     //Word Address
	   break;
	
	case 'D':      //Bit Address
	   break;
	   
	 case 'P':      //Word Address
	   break;
	   
	 case 'T':    //Word Address
	   break;
	   
	 case 'C':     //Word Address
	   break;
	   
	 case 'X':     //Bit Address
	   break;
	
	 case 'Y':     //Word Address
	   break;
	   
	case 'S':      //Word Address
	   break;